<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>InfinityChatter</title>
  <link rel="icon" href="/static/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/static/favicon.png">
  <link rel="shortcut icon" href="/static/favicon.png">
  <link rel="manifest" href="/static/manifest.json">
  <meta name="theme-color" content="#0f172a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="InfinityChatter">
  <meta name="mobile-web-app-capable" content="yes">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    header.inbox-header { position:fixed; top:0; left:0; right:0; height:64px; display:flex; align-items:center; justify-content:center; background: rgba(255,255,255,0.9); backdrop-filter: blur(6px); z-index:50; box-shadow:0 1px 6px rgba(0,0,0,0.04); }
    main.inbox-main { padding:1px 16px 5px; max-width:980px; margin:0 auto; }
    .contact-card { display:flex; gap:12px; align-items:center; padding:12px; border-radius:12px; margin-bottom:12px; background:#fff; cursor:pointer; box-shadow:0 6px 18px rgba(2,6,23,0.04); }
    .contact-avatar{ width:56px; height:56px; border-radius:12px; overflow:hidden; display:flex; align-items:center; justify-content:center; background:#eef; font-weight:700; }
    .bottom-nav{ position:fixed; left:50%; transform:translateX(-50%); bottom:16px; width: min(760px, calc(100% - 36px)); background: rgba(255,255,255,0.65); backdrop-filter: blur(8px); border-radius:18px; padding:8px 14px; display:flex; justify-content:space-around; align-items:center; z-index:60; }
    .nav-item{ display:flex; flex-direction:column; align-items:center; font-size:0.9rem; color:#0f172a; cursor:pointer; padding:6px 8px; border-radius:10px; }
    #pageContent {
      position: relative;
      transition: transform .35s ease;
      will-change: transform;
      overflow-x: hidden;
    }
    body {
      overflow-x: hidden;
    }
    .contact-menu-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      border-radius: 50%;
      padding: 8px;
      transition: background 0.2s;
      color: #64748b;
    }
    .contact-menu-btn:hover {
      background: rgba(148, 163, 184, 0.15);
    }
    .contact-popover {
      position: absolute;
      right: 10px;
      top: 58%;
      transform: translateY(-50%) scale(0.9);
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(14px) saturate(180%);
      -webkit-backdrop-filter: blur(14px) saturate(180%);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-shadow: 0 12px 35px rgba(0,0,0,0.15);
      min-width: 160px;
      overflow: hidden;
      opacity: 0;
      transition: all 0.25s cubic-bezier(0.19, 1, 0.22, 1);
      z-index: 999;
    }
    .contact-popover.show {
      opacity: 1;
      transform: translateY(-50%) scale(1);
    }
    .contact-popover button {
      display: block;
      width: 100%;
      padding: 10px 14px;
      border: none;
      background: transparent;
      text-align: left;
      color: #0f172a;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .contact-popover button:hover {
      background: rgba(255, 255, 255, 0.35);
    }
    .contact-popover .danger {
      color: #dc2626;
    }
    /* page view container + sliding animations */
    #mainContent { position: relative; overflow: hidden; }
    
    /* child views we inject */
    .page-view {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      will-change: transform, opacity;
      transition: transform 320ms cubic-bezier(.2,.9,.3,1), opacity 220ms ease;
      transform: translateX(0);
      opacity: 1;
    }
    
    /* Enter/Exit positions */
    .page-enter-from-right  { transform: translateX(18%); opacity: 0; }
    .page-enter-from-left   { transform: translateX(-18%); opacity: 0; }
    .page-enter-to-center   { transform: translateX(0); opacity: 1; }
    
    .page-exit-to-left      { transform: translateX(-18%); opacity: 0; }
    .page-exit-to-right     { transform: translateX(18%); opacity: 0; }
    
    /* small shadow to emphasize layering */
    .page-view .page-inner {
      background: transparent; /* keep your page background */
      height: 100%;
      box-shadow: 0 8px 24px rgba(2,6,23,0.06);
    }
    
    /* optional: subtle fade on old content while animating */
    .page-view.exiting { pointer-events: none; }
  </style>
</head>
<body>
 <header class="inbox-header">
    <div style="width:100%;max-width:980px;text-align:center;position:relative;">
      <div style="font-weight:800;font-size:18px;">InfinityChatter</div>
      <div style="font-size:0.9rem;color:#64748b;margin-top:2px;">
        <span id="myNameHeader"></span>
      </div>
  </header>
  
  <div id="pageContent" style="min-height:60vh;">
    <main class="inbox-main">
      <div id="contactsContainer">
        <div style="padding:18px;color:#64748b">Loading contacts‚Ä¶</div>
      </div>
    </main>
  </div>
  
  <div class="bottom-nav" role="navigation" aria-label="main navigation">
    <div class="nav-item" id="nav-chats" data-id="chats" data-path="/inbox"><div>Chats</div></div>
    <div class="nav-item" id="nav-calls" data-id="calls" data-path="/calls"><div>Calls</div></div>
    <div class="nav-item" id="nav-Updates" data-id="Updates" data-path="/updates"><div>Updates</div></div>
    <div class="nav-item" id="nav-settings" data-id="settings" data-path="/settings"><div>Settings</div></div>
  </div>
<script>
(function () {
  const DB_NAME = 'infinity_offline_v3';
  const DB_VERSION = 2;
  const STORE_MESSAGES = 'messages';
  const STORE_CONTACTS = 'contacts';
  const STORE_STATUSES = 'statuses';
  const STORE_OUTBOX = 'outbox';
  const STORE_META = 'meta';

  const SYNC_INTERVAL_MS = 30 * 1000;
  const BACKOFF_BASE = 2000;

  let CONTACTS_CACHE = null;
  let MESSAGES_INDEX_CACHE = {};

  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (ev) => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE_MESSAGES)) {
          const ms = db.createObjectStore(STORE_MESSAGES, { keyPath: 'id' });
          ms.createIndex('by_contact', 'contact', { unique: false });
          ms.createIndex('created_at', 'created_at', { unique: false });
        }
        if (!db.objectStoreNames.contains(STORE_CONTACTS)) {
          db.createObjectStore(STORE_CONTACTS, { keyPath: 'contact' });
        }
        if (!db.objectStoreNames.contains(STORE_STATUSES)) {
          const ss = db.createObjectStore(STORE_STATUSES, { keyPath: 'id' });
          ss.createIndex('createdAt', 'createdAt', { unique: false });
        }
        if (!db.objectStoreNames.contains(STORE_OUTBOX)) {
          db.createObjectStore(STORE_OUTBOX, { keyPath: 'oid', autoIncrement: true });
        }
        if (!db.objectStoreNames.contains(STORE_META)) {
          db.createObjectStore(STORE_META, { keyPath: 'key' });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function withStore(storeName, mode, fn) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(storeName, mode);
      const store = tx.objectStore(storeName);
      try {
        const result = fn(store);
        tx.oncomplete = () => resolve(result);
        tx.onerror = () => reject(tx.error);
      } catch (e) {
        reject(e);
      }
    });
  }

  async function metaGet(key) {
    return withStore(STORE_META, 'readonly', store => new Promise((res) => {
      const r = store.get(key);
      r.onsuccess = () => res(r.result ? r.result.value : null);
      r.onerror = () => res(null);
    }));
  }
  async function metaSet(key, value) {
    return withStore(STORE_META, 'readwrite', store => store.put({ key, value }));
  }

  // cleanup stray 'self*' contact keys (keep exact 'self' only)
  async function _cleanupSelfVariants() {
    try {
      await withStore(STORE_CONTACTS, 'readwrite', store => new Promise((res) => {
        const req = store.openCursor();
        req.onsuccess = (e) => {
          const cur = e.target.result;
          if (!cur) return res(true);
          const key = String(cur.primaryKey || cur.value.contact || '').toLowerCase();
          if (key.startsWith('self') && key !== 'self') {
            try { store.delete(cur.primaryKey); } catch (ignored) {}
          }
          cur.continue();
        };
        req.onerror = () => res(true);
      }));
    } catch (e) {
      // best-effort cleanup
    }
  }

  const OfflineDB = {
    _syncTimer: null,
    _isSyncing: false,
    _onSyncStart: null,
    _onSyncEnd: null,

    _getProfileId() {
      try {
        const p = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
        return p.contact || p.username || p.name || p.phone || null;
      } catch (e) { return null; }
    },

    _ensureSelfEntryObject() {
      const p = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
      const username = p.name || p.username || 'You';
      return {
        contact: 'self',
        name: `${username} (You)`,
        last_text: 'Message Yourself',
        last_ts: Math.floor(Date.now() / 1000),
        avatar_url: p.avatar_url || p.avatar || null,
        added_at: Date.now()
      };
    },

    async init() {
      await openDB();
      await _cleanupSelfVariants();
      window.addEventListener('online', () => { this.syncNow().catch(()=>{}); });
      // warm caches minimally
      CONTACTS_CACHE = null;
    },

    _shouldSkipContact(row) {
      if (!row || !row.contact) return true;
      const cid = String(row.contact).toLowerCase();
      if (cid === 'self') return true;
      const me = this._getProfileId();
      if (me && String(me).toLowerCase() === cid) return true;
      return false;
    },

    async listContacts() {
      if (CONTACTS_CACHE) return CONTACTS_CACHE.slice();
      const arr = await withStore(STORE_CONTACTS, 'readonly', store => new Promise((res) => {
        const out = [];
        const req = store.openCursor();
        req.onsuccess = e => {
          const cur = e.target.result;
          if (!cur) return res(out);
          out.push(cur.value);
          cur.continue();
        };
        req.onerror = () => res([]);
      }));
      // remove stray self variants, keep only exact 'self'
      const nonSelf = arr.filter(c => {
        const cid = String((c || {}).contact || '').toLowerCase();
        return cid !== 'self';
      });

      const self = this._ensureSelfEntryObject();
      const merged = [self].concat(nonSelf);
      CONTACTS_CACHE = merged;
      return merged.slice();
    },

    async saveContactLocal(contact) {
      const entry = Object.assign({}, contact);
      if (!entry.contact) entry.contact = entry.contact_name || entry.phone || ('c-' + Date.now());
      if (!entry.added_at) entry.added_at = Date.now();
      if (this._shouldSkipContact(entry)) return entry;
      await withStore(STORE_CONTACTS, 'readwrite', s => s.put(entry));
      CONTACTS_CACHE = null;
      await this.enqueueOutbox({ type: 'contact', payload: entry });
      return entry;
    },

    // replace local contacts with server list, but preserve single canonical 'self'
    async replaceContactsFull(serverContacts = []) {
      const self = this._ensureSelfEntryObject();
      await withStore(STORE_CONTACTS, 'readwrite', store => new Promise((resolve) => {
        const req = store.openCursor();
        req.onsuccess = (e) => {
          const cur = e.target.result;
          if (!cur) return resolve(true);
          const key = String(cur.primaryKey || cur.value.contact || '').toLowerCase();
          if (key === 'self') {
            cur.continue();
          } else {
            try { store.delete(cur.primaryKey); } catch (ignored) {}
            cur.continue();
          }
        };
        req.onerror = () => resolve(true);
      }));

      for (const sc of serverContacts) {
        const row = {
          contact: sc.contact || sc.contact_name || ('c-' + Date.now() + '-' + Math.random().toString(36).slice(2,6)),
          name: sc.contact_name || sc.name || '',
          phone: sc.phone || '',
          avatar_url: sc.avatar || sc.avatar_url || '',
          added_at: sc.added_at || Date.now()
        };
        if (String(row.contact).toLowerCase() === 'self') continue;
        await withStore(STORE_CONTACTS, 'readwrite', s => s.put(row));
      }

      await withStore(STORE_CONTACTS, 'readwrite', s => s.put(self));
      CONTACTS_CACHE = null;
    },

    async saveMessageLocal(msg) {
      const entry = Object.assign({}, msg);
      if (!entry.id) entry.id = 'local-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);
      if (!entry.contact) entry.contact = entry.to || entry.peer || 'unknown';
      if (!entry.created_at) entry.created_at = Date.now();
      await withStore(STORE_MESSAGES, 'readwrite', s => s.put(entry));
      const last = MESSAGES_INDEX_CACHE[entry.contact] || 0;
      if ((entry.created_at || 0) > last) MESSAGES_INDEX_CACHE[entry.contact] = entry.created_at;
      if (!this._looksServerMessage(entry)) await this.enqueueOutbox({ type: 'message', payload: entry });
      return entry;
    },

    async getMessagesForContact(contactId, { since = 0, limit = 1000 } = {}) {
      return withStore(STORE_MESSAGES, 'readonly', store => new Promise((res) => {
        const out = [];
        const idx = store.index('created_at');
        const req = idx.openCursor(null, 'prev');
        req.onsuccess = (e) => {
          const cur = e.target.result;
          if (!cur) return res(out);
          const v = cur.value;
          const c = v.contact || v.to || v.peer;
          if (String(c) === String(contactId) && (v.created_at || 0) >= since) out.push(v);
          if (out.length >= limit) return res(out);
          cur.continue();
        };
        req.onerror = () => res(out);
      }));
    },

    async saveStatusLocal(status) {
      const entry = Object.assign({}, status);
      if (!entry.id) entry.id = 's-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);
      if (!entry.createdAt) entry.createdAt = Date.now();
      if (!entry.expiresAt) entry.expiresAt = entry.createdAt + (24 * 60 * 60 * 1000);
      await withStore(STORE_STATUSES, 'readwrite', s => s.put(entry));
      await this.enqueueOutbox({ type: 'status', payload: entry });
      return entry;
    },

    async listStatuses() {
      return withStore(STORE_STATUSES, 'readonly', store => new Promise((res) => {
        const out = [];
        const req = store.openCursor(null, 'prev');
        req.onsuccess = e => {
          const cur = e.target.result;
          if (!cur) return res(out);
          const v = cur.value;
          if (!v.expiresAt || v.expiresAt > Date.now()) out.push(v);
          cur.continue();
        };
        req.onerror = () => res([]);
      }));
    },

    async enqueueOutbox(op) {
      await withStore(STORE_OUTBOX, 'readwrite', s => s.add({ op, created_at: Date.now() }));
      this.syncNow().catch(()=>{});
    },

    async _drainOutboxOnce() {
      const ops = await withStore(STORE_OUTBOX, 'readonly', s => new Promise((res) => {
        const arr = [];
        const r = s.openCursor();
        r.onsuccess = e => {
          const cur = e.target.result;
          if (!cur) return res(arr);
          arr.push({ key: cur.primaryKey, value: cur.value });
          cur.continue();
        };
        r.onerror = () => res(arr);
      }));

      for (const item of ops) {
        const { key, value } = item;
        try {
          const op = value.op;
          if (op.type === 'message') {
            const payload = {
              text: op.payload.text || '',
              attachments: op.payload.attachments || [],
              contact: op.payload.contact || op.payload.to || op.payload.peer,
              sender: op.payload.sender || (JSON.parse(localStorage.getItem('infinity_profile') || '{}').name || undefined),
              created_at: op.payload.created_at || Date.now()
            };
            const res = await fetch('/send_message', {
              method: 'POST',
              credentials: 'include',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error('send_failed');
            const j = await res.json().catch(()=>null);
            if (j && j.message && j.message.id) {
              await withStore(STORE_MESSAGES, 'readwrite', s => s.put(Object.assign({}, j.message)));
            }
            await withStore(STORE_OUTBOX, 'readwrite', s => s.delete(key));
          } else if (op.type === 'contact') {
            const profile = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
            const owner = profile.username || profile.name;
          
            const payload = {
              owner,
              contacts: [
                {
                  contact: op.payload.contact,
                  name: op.payload.name || op.payload.contact
                }
              ]
            };
          
            const res = await fetch('/contacts_list', {
              method: 'POST',
              credentials: 'include',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
          
            if (!res.ok) throw new Error('contact_sync_failed');
          
            await withStore(STORE_OUTBOX, 'readwrite', s => s.delete(key));
          } else {
            await withStore(STORE_OUTBOX, 'readwrite', s => s.delete(key));
          }
        } catch (err) {
          throw err;
        }
      }
      return true;
    },

    async _pullFromServer() {
      try {
        const contactsRes = await fetch('/contacts_list', { credentials: 'include' });
        if (contactsRes && contactsRes.ok) {
          const j = await contactsRes.json().catch(()=>null);
          const contacts = j && j.contacts ? j.contacts : (Array.isArray(j) ? j : []);
          const normalized = contacts.map(c => ({
            contact: c.contact || c.contact_name || (c.phone ? 'phone:'+c.phone : ('c-'+Date.now()+'-'+Math.random().toString(36).slice(2,6))),
            name: c.contact_name || c.name || '',
            phone: c.phone || '',
            avatar_url: c.avatar || c.avatar_url || '',
            added_at: c.added_at || Date.now()
          }));
          await this.replaceContactsFull(normalized);
        }
      } catch (e) { /* ignore */ }

      try {
        let lastMsgTs = await metaGet('last_server_msg_ts') || 0;
        const messagesRes = await fetch('/api/messages?since=' + encodeURIComponent(lastMsgTs), { credentials: 'include' });
        if (messagesRes && messagesRes.ok) {
          const j = await messagesRes.json().catch(()=>null);
          const msgs = j && j.messages ? j.messages : (Array.isArray(j) ? j : []);
          let maxTs = lastMsgTs || 0;
          for (const m of msgs) {
            const mm = Object.assign({}, m);
            if (!mm.id) mm.id = 'srv-' + (mm.created_at || Date.now()) + '-' + Math.random().toString(36).slice(2,6);
            mm.created_at = mm.created_at || mm.createdAt || Date.now();
            mm.contact = mm.contact || mm.to || mm.peer || mm.sender || 'unknown';
            await withStore(STORE_MESSAGES, 'readwrite', s => s.put(mm));
            if ((mm.created_at || 0) > maxTs) maxTs = mm.created_at;
            const c = mm.contact;
            const prev = MESSAGES_INDEX_CACHE[c] || 0;
            if ((mm.created_at || 0) > prev) MESSAGES_INDEX_CACHE[c] = mm.created_at;
          }
          if (maxTs) await metaSet('last_server_msg_ts', maxTs);
        }
      } catch (e) { /* ignore */ }
      return true;
    },

    async syncNow() {
      if (this._isSyncing) return;
      this._isSyncing = true;
      if (typeof this._onSyncStart === 'function') this._onSyncStart();
      try {
        let attempt = 0;
        while (true) {
          try {
            await this._drainOutboxOnce();
            break;
          } catch (err) {
            attempt++;
            if (attempt > 4) throw err;
            await new Promise(r => setTimeout(r, BACKOFF_BASE * attempt));
          }
        }
        await this._pullFromServer();
        CONTACTS_CACHE = null;
        try {
          if (typeof window.renderContacts === 'function') {
            const all = await this.listContacts();
            window.renderContacts(all);
          }
        } catch (e) {}
        if (typeof this._onSyncEnd === 'function') this._onSyncEnd(null);
        return true;
      } catch (err) {
        if (typeof this._onSyncEnd === 'function') this._onSyncEnd(err);
        throw err;
      } finally {
        this._isSyncing = false;
      }
    },

    _startPeriodicSync() {
      if (this._syncTimer) clearInterval(this._syncTimer);
      this._syncTimer = setInterval(() => {
        if (navigator.onLine) this.syncNow().catch(()=>{});
      }, SYNC_INTERVAL_MS);
    },

    _looksServerMessage(m) {
      if (!m || !m.id) return false;
      return String(m.id).match(/^[0-9]+$/);
    },

    async exportBackup(filename = null) {
      const contacts = await this.listContacts();
      const statuses = await this.listStatuses();
      const messages = await withStore(STORE_MESSAGES, 'readonly', store => new Promise((res) => {
        const arr = [];
        const req = store.openCursor();
        req.onsuccess = e => {
          const cur = e.target.result; if (!cur) return res(arr);
          arr.push(cur.value); cur.continue();
        };
        req.onerror = () => res(arr);
      }));
      const outbox = await withStore(STORE_OUTBOX, 'readonly', store => new Promise((res) => {
        const arr = [];
        const r = store.openCursor();
        r.onsuccess = e => {
          const cur = e.target.result; if (!cur) return res(arr);
          arr.push(cur.value); cur.continue();
        };
        r.onerror = () => res(arr);
      }));
      const meta = {
        last_server_msg_ts: await metaGet('last_server_msg_ts') || 0,
        app_version: await metaGet('app_version') || null
      };
      const full = { exported_at: Date.now(), contacts, statuses, messages, outbox, meta };
      const blob = new Blob([JSON.stringify(full, null, 2)], { type: 'application/json' });
      const fname = filename || `infinity_backup_${(new Date()).toISOString().replace(/[:.]/g,'-')}.json`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = fname; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 60000);
      return true;
    },

    async importBackupFile(file) {
      const text = await file.text();
      const obj = JSON.parse(text);
      if (!obj) throw new Error('invalid_backup');
      const { contacts = [], statuses = [], messages = [], outbox = [], meta = {} } = obj;
      for (const c of contacts) await withStore(STORE_CONTACTS, 'readwrite', s => s.put(c));
      for (const s of statuses) await withStore(STORE_STATUSES, 'readwrite', s2 => s2.put(s));
      for (const m of messages) await withStore(STORE_MESSAGES, 'readwrite', s3 => s3.put(m));
      for (const o of outbox) await withStore(STORE_OUTBOX, 'readwrite', s4 => s4.add(o));
      if (meta && meta.last_server_msg_ts) await metaSet('last_server_msg_ts', meta.last_server_msg_ts);
      if (meta && meta.app_version) await metaSet('app_version', meta.app_version);
      CONTACTS_CACHE = null;
      return true;
    },

    onSyncStart(fn) { this._onSyncStart = fn; },
    onSyncEnd(fn) { this._onSyncEnd = fn; }
  };

  window.OfflineDB = OfflineDB;

  async function startOfflineDB(options = { checkAppVersion: true }) {
    if (window._offlineDBStarted) return;
    window._offlineDBStarted = true;

    const profile = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
    const username = profile.username || profile.name || null;

    await OfflineDB.init();
    OfflineDB._startPeriodicSync();

    try { await OfflineDB.listContacts(); } catch (e) {}
    try { await OfflineDB.syncNow(); } catch (e) {}

    if (options && options.checkAppVersion) {
      try {
        const res = await fetch('/api/app_version', { credentials: 'include' });
        if (res && res.ok) {
          const j = await res.json().catch(()=>null);
          const serverVer = j && j.version ? j.version : null;
          const localVer = await metaGet('app_version');
          if (serverVer && serverVer !== localVer) {
            await metaSet('app_version', serverVer);
            try { location.reload(true); } catch (e) { location.reload(); }
          } else {
            if (serverVer) await metaSet('app_version', serverVer);
          }
        }
      } catch (e) {}
    }
  }

  window.startOfflineDB = startOfflineDB;
})();
</script>
<script>
(async () => {
  const profile = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
  if (profile && profile.username) {
    await fetch('/api/set_session', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username: profile.username })
    });
  }
})();
(async function(){
  // Requires cs.socket or window.socket for socket.io if you use it
  const socket = window.socket || (window.cs && cs.socket);

  // create Add Contacts box (rounded rectangle)
  function createAddContactsButton() {
    const box = document.createElement('div');
    box.id = 'addContactsBox';
    box.style.cssText = `
      width:calc(100% - 40px);
      max-width:480px;
      margin:18px auto;
      padding:14px 16px;
      border-radius:12px;
      box-shadow:0 4px 20px rgba(15,27,43,0.06);
      background:linear-gradient(180deg, #fff, #fbfdff);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      font-family:Poppins, sans-serif;
    `;
    box.innerHTML = `
      <div style="display:flex;align-items:center;gap:12px">
        <div style="width:44px;height:44px;border-radius:10px;background:#eef;padding:6px;display:flex;align-items:center;justify-content:center;font-weight:700">+</div>
        <div>
          <div style="font-weight:600">Add Contacts</div>
          <div style="font-size:12px;color:#6b7280">Import from device or share a link</div>
        </div>
      </div>
      <div><button id="openAddContactsBtn" style="padding:8px 12px;border-radius:8px;border:none;background:#0f172a;color:white;cursor:pointer">Open</button></div>
    `;
    return box;
  }

  // insert box at top of main content (adjust selector to your page)
  const container = document.querySelector('#main') || document.body;
  const existing = document.getElementById('addContactsBox');
  if (!existing) {
    const btn = createAddContactsButton();
    container.prepend(btn);
    const openBtn = document.getElementById('openAddContactsBtn');
    if (openBtn) openBtn.addEventListener('click', openAddContactsModal);
  }

  // modal UI builder (no CSV / paste)
  function openAddContactsModal(){
    // overlay
    const overlay = document.createElement('div');
    overlay.id = 'addContactsOverlay';
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:2000;';
    const dialog = document.createElement('div');
    dialog.style.cssText = 'width:92%;max-width:720px;background:white;padding:18px;border-radius:12px;box-shadow:0 10px 40px rgba(2,6,23,0.2);font-family:Poppins, sans-serif;';
    dialog.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
        <strong style="font-size:18px">Add Contacts</strong>
        <button id="closeAddContacts" style="background:none;border:none;font-size:18px">‚úñ</button>
      </div>
      <div style="display:flex;gap:12px;margin-bottom:10px">
        <button id="useContactPicker" style="flex:1;padding:10px;border-radius:8px;background:#e0e7ff;">Pick from device</button>
        <button id="createInviteLinkBtn" style="flex:1;padding:10px;border-radius:8px;background:#2563eb;color:white;">Create Invite Link</button>
      </div>
      <div id="addContactsResult" style="max-height:320px;overflow:auto"></div>
    `;
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);

    document.getElementById('closeAddContacts')?.addEventListener('click', ()=> overlay.remove());
    document.getElementById('useContactPicker')?.addEventListener('click', pickContactsFromDevice);
    document.getElementById('createInviteLinkBtn')?.addEventListener('click', createInstantShareLink);
  }

  async function handleContactCheck(list, resultDiv) {
    const found = [];
    const notFound = [];
  
    for (const c of list) {
      try {
        const res = await fetch('/api/check_phone', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ phone: c.phone })
        });
  
        const j = await res.json();
  
        if (j && j.registered) {
          // already a user ‚Üí auto-add contact
          await addContactToLocalDB({
            contact: j.username,      // unique identifier
            name: j.display_name || c.name || j.username,
            phone: c.phone
          });
          found.push(c);
        } else {
          notFound.push(c);
        }
  
      } catch (err) {
        console.error('Check failed', err);
        notFound.push(c);
      }
    }
  
    // UI results
    let html = "";
  
    if (found.length) {
      html += `<div style="margin-bottom:10px;color:green;"><b>Added contacts:</b></div>`;
      found.forEach(f => {
        html += `<div style="margin-bottom:6px">‚úî ${f.name} (${f.phone})</div>`;
      });
    }
  
    if (notFound.length) {
      html += `<div style="margin-top:14px;color:#b91c1c;"><b>These people are not on InfinityChatter:</b></div>`;
      notFound.forEach(f => {
        html += `<div style="margin-bottom:6px">‚úñ ${f.name} (${f.phone})</div>`;
      });
      html += `<div style="margin-top:8px">Ask them to join using the Invite Link.</div>`;
    }
  
    resultDiv.innerHTML = html;
  }
  
  async function addContactToLocalDB(c) {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open("infinity_offline_v3", 2);
  
      req.onerror = () => reject(req.error);
  
      req.onsuccess = () => {
        const db = req.result;
        const tx = db.transaction("contacts", "readwrite");
        const store = tx.objectStore("contacts");
  
        const row = {
          contact: c.contact,
          name: c.name || c.contact,
          phone: c.phone,
          last_text: "",
          last_ts: Date.now() / 1000,
          avatar_url: ""
        };
  
        const putReq = store.put(row);
        putReq.onsuccess = () => resolve(true);
        putReq.onerror = () => reject(putReq.error);
      };
    });
  }

  async function pickContactsFromDevice() {
    const resultDiv = document.getElementById('addContactsResult');
    if (!resultDiv) return;
  
    resultDiv.innerHTML = '<div>Requesting contact permission...</div>';
  
    try {
      if (!('contacts' in navigator) || typeof navigator.contacts.select !== 'function') {
        resultDiv.innerHTML = '<div>Your browser does not support the Contacts Picker API.</div>';
        return;
      }
  
      const props = ['name', 'tel'];
      const opts = { multiple: true };
  
      // üìå Permission request happens here
      const contacts = await navigator.contacts.select(props, opts);
  
      if (!contacts || !contacts.length) {
        resultDiv.innerHTML = '<div>No contact selected.</div>';
        return;
      }
  
      // Normalize phone/name list
      const normalized = [];
      for (const c of contacts) {
        const name = Array.isArray(c.name) ? c.name[0] : c.name || "";
        const tels = Array.isArray(c.tel) ? c.tel : (c.tel ? [c.tel] : []);
        for (const t of tels) {
          const phone = normalizePhone(t);
          if (phone) normalized.push({ name, phone });
        }
      }
  
      if (!normalized.length) {
        resultDiv.innerHTML = '<div>No valid phone numbers found.</div>';
        return;
      }
  
      resultDiv.innerHTML = '<div>Checking users...</div>';
  
      // üî• NOW check every phone with your backend
      handleContactCheck(normalized, resultDiv);
  
    } catch (err) {
      console.error(err);
      resultDiv.innerHTML = '<div>Permission denied or error accessing contacts.</div>';
    }
  }
  
  function normalizePhone(s){
    if(!s) return '';
    // very simple normalization: keep digits and leading +
    return (s + '').replace(/[^0-9+]/g, '');
  }

  // show selected contacts UI and send to server
  function showSelectedAndSend(list){
    const resultDiv = document.getElementById('addContactsResult');
    if (!resultDiv) return;
    const uniq = [];
    const seen = new Set();
    for(const it of list){
      if(!it.phone) continue;
      const p = normalizePhone(it.phone);
      if(!p) continue;
      if(seen.has(p)) continue;
      seen.add(p);
      uniq.push({name: it.name || '', phone: p});
    }
    if(!uniq.length){ resultDiv.innerHTML = '<div>No valid phone numbers found.</div>'; return;}
    resultDiv.innerHTML = '<div style="margin-bottom:8px">Selected contacts:</div>';
    const ul = document.createElement('div');
    ul.style.display = 'grid';
    ul.style.gridTemplateColumns = '1fr 120px';
    ul.style.gap = '8px';
    for(const u of uniq){
      const left = document.createElement('div');
      left.textContent = (u.name || '(no name)') + ' ‚Äî ' + u.phone;
      const right = document.createElement('div');
      const btn = document.createElement('button');
      btn.textContent = 'Add';
      btn.style.padding = '6px 10px';
      btn.style.borderRadius = '8px';
      btn.addEventListener('click', ()=> sendSelectedToServer([u]));
      right.appendChild(btn);
      ul.appendChild(left); ul.appendChild(right);
    }
    // bulk add button
    const bulk = document.createElement('div');
    bulk.style.gridColumn = '1/-1';
    bulk.innerHTML = `<div style="margin-top:12px"><button id="bulkAddBtn" style="padding:8px 12px;border-radius:10px;background:#0f172a;color:#fff">Add All ${uniq.length}</button></div>`;
    resultDiv.appendChild(ul); resultDiv.appendChild(bulk);
    document.getElementById('bulkAddBtn')?.addEventListener('click', ()=> sendSelectedToServer(uniq));
  }

  // send to server /contacts_list
  async function sendSelectedToServer(items){
    const resultDiv = document.getElementById('addContactsResult');
    if (!resultDiv) return;
    resultDiv.innerHTML = '<div>Saving contacts‚Ä¶</div>';
    try {
      const resp = await fetch('/contacts_list', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({contacts: items})
      });
      const j = await resp.json().catch(()=>({}));
      if (!resp.ok) {
        resultDiv.innerHTML = `<div style="color:red">Error: ${j.error || resp.status}</div>`;
        return;
      }
      // present: numbers that are on InfinityChatter
      let html = '<div style="margin-bottom:8px"><strong>Result</strong></div>';
      if (j.present && j.present.length){
        html += '<div style="margin-bottom:8px">These contacts are on InfinityChatter:</div>';
        j.present.forEach(p => html += `<div>${p.phone} ‚Äî ${p.username}</div>`);
      }
      if (j.missing && j.missing.length){
        html += '<div style="margin-top:10px;color:#b91c1c">These numbers are NOT on InfinityChatter:</div>';
        j.missing.forEach(m => {
          html += `<div style="display:flex;gap:8px;align-items:center;margin-top:6px">
                     <div style="flex:1">${m.phone}</div>
                     <button class="shareInviteBtn" data-phone="${m.phone}" style="padding:6px 10px;border-radius:8px">Share invite</button>
                   </div>`;
        });
      }
      resultDiv.innerHTML = html;
      // wire share invite buttons ‚Äî create link WITHOUT prompting for number (but send phone in body if available)
      Array.from(document.getElementsByClassName('shareInviteBtn')).forEach(b=>{
          b.addEventListener('click', async (ev)=>{
            const phone = b.dataset.phone || null;
            b.textContent = 'Creating‚Ä¶';
        
            // get saved profile name
            const profile = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
            const username = profile.name || profile.username || null;
        
            const body = phone ? { phone } : {};
            if (username) body.username = username;  // include username if available
        
            const r = await fetch('/api/create_contact_invite', {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(body)
            });
        
            const jr = await r.json().catch(()=>({}));
        
            if (jr && jr.url) {
              await navigator.clipboard.writeText(jr.url).catch(()=>{});
              b.textContent = 'Copied link';
              if (navigator.share) {
                try {
                  await navigator.share({title:'Join me on InfinityChatter', text:'Join me on InfinityChatter ‚ôæÔ∏è', url: jr.url});
                } catch(e){}
              } else {
                alert('Invite link copied to clipboard:\n' + jr.url);
              }
            } else {
              b.textContent = 'Error';
            }
          });
      });
    } catch (err) {
      console.error(err);
      resultDiv.innerHTML = '<div style="color:red">Network or internal error.</div>';
    }
  }

  async function createInstantShareLink(){
      const resDiv = document.getElementById('addContactsResult');
      if (!resDiv) return;
      resDiv.innerHTML = 'Creating invite link...';
    
      // read local profile (if you store it)
      const profile = JSON.parse(localStorage.getItem('infinity_profile')||'{}');
      const username = profile.name || profile.username || null; // best-effort identity
    
      try {
        const res = await fetch('/api/create_contact_invite', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(username ? { username } : {}) // include username if available
        });
        const j = await res.json().catch(()=>({}));
        if (res.ok && j && j.url) {
          // same behavior as earlier
          await navigator.clipboard.writeText(j.url).catch(()=>{});
          resDiv.innerHTML = `
              <div>‚úÖ Invite link created!<br><br>
                <div style="display:flex;gap:8px;align-items:center;">
                  <input id="inviteLinkInput" style="flex:1;padding:6px;border:1px solid #ccc;border-radius:8px" value="${j.url}" readonly />
                  <button id="copyInviteLinkBtn" style="padding:6px 10px;border-radius:8px;background:#0f172a;color:#fff;">Copy</button>
                </div>
              </div>`;
              
          document.getElementById('copyInviteLinkBtn')?.addEventListener('click', async ()=>{
              const link = document.getElementById('inviteLinkInput').value;
              await navigator.clipboard.writeText(link).catch(()=>{});
              alert('Copied link to clipboard!');
          });

        } else {
          resDiv.innerHTML = `<div style="color:red">Failed to create link: ${j.error || res.status}</div>`;
        }
      } catch (err) {
        console.error(err);
        resDiv.innerHTML = '<div style="color:red">Network or internal error.</div>';
      }
  }
  window.openAddContactsModal = openAddContactsModal;
})();

(function(){
  // --- basic checks & profile ---
  const profile = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
  if (!profile.name) { window.location.href = '/login'; return; }
  const myNameEl = document.getElementById('myNameHeader');
  if (myNameEl) myNameEl.textContent = profile.name || '';

  // --- socket: init & register (if available) ---
  (function initSocketRegistration(){
    try {
      const profileLocal = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
      const username = (profileLocal.name || profileLocal.username || '').trim();
      if (!window.socket && typeof window.io === 'function') {
        try { window.socket = io(); } catch (e) { console.warn('socket.io init failed', e); }
      }
      const socket = window.socket || (window.cs && cs.socket);
      if (!socket || !username) return;

      if (socket.connected) socket.emit('register_socket', { username });
      else socket.on('connect', () => socket.emit('register_socket', { username }));

      socket.on('contact_added_by_invite', data => {
        try { loadContacts(); } catch (e) { console.warn('loadContacts reload failed', e); }
        if (typeof showToast === 'function') showToast(`New contact: ${data.new_name}`);
        else {
          const el = document.createElement('div');
          el.textContent = `New contact: ${data.new_name}`;
          el.style.cssText = 'position:fixed;bottom:120px;left:50%;transform:translateX(-50%);background:#111;color:#fff;padding:8px 12px;border-radius:8px;z-index:3000';
          document.body.appendChild(el);
          setTimeout(()=> el.remove(), 3500);
        }
      });
    } catch (err) {
      console.warn('socket init err', err);
    }
  })();

  // --- helpers ---
  function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // header add button helpers
  function ensureHeaderAddButton() {
    if (document.getElementById('headerAddBtn')) return;
    const header = document.querySelector('header');
    if (!header) return;
    const btn = document.createElement('button');
    btn.id = 'headerAddBtn';
    btn.title = 'Add Contact';
    btn.textContent = '+';
    btn.style.cssText = `
      position:absolute; right:18px; top:14px; width:38px; height:38px;
      border-radius:50%; background:#0f172a; color:#fff; font-size:24px; border:none;
      cursor:pointer; box-shadow:0 3px 8px rgba(0,0,0,0.1); display:flex;align-items:center;justify-content:center;
    `;
    btn.addEventListener('click', () => { if (typeof openAddContactsModal === 'function') openAddContactsModal(); });
    header.appendChild(btn);
  }
  function removeHeaderAddButton(){
    const b = document.getElementById('headerAddBtn');
    if (b) b.remove();
  }

  // --- popover CSS (single injection) ---
  if (!document.getElementById('contact-popover-style')) {
    const s = document.createElement('style');
    s.id = 'contact-popover-style';
    s.textContent = `
      .contact-popover {
        position: absolute;
        min-width:160px;
        padding:8px;
        border-radius:12px;
        box-shadow: 0 8px 30px rgba(2,6,23,0.12);
        backdrop-filter: blur(8px) saturate(120%);
        background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(250,250,250,0.9));
        color: #0f172a;
        z-index: 4000;
        transform-origin: top right;
        opacity: 0;
        transform: translateY(-6px) scale(.98);
        transition: opacity .18s ease, transform .18s cubic-bezier(.2,.9,.3,1);
        overflow: hidden;
      }
      .contact-popover.show { opacity:1; transform: translateY(0) scale(1); }
      .contact-popover button { display:block; width:100%; text-align:left; padding:8px 10px; border:none; background:transparent; font-size:0.95rem; cursor:pointer; border-radius:8px; }
      .contact-popover button:hover { background: rgba(15,23,42,0.04); }
      .contact-popover .danger { color:#b91c1c; }
    `;
    document.head.appendChild(s);
  }

  // closes any popovers attached to body
  function closeAllContactMenus() {
    document.querySelectorAll('.contact-popover').forEach(p => p.remove());
    document.querySelectorAll('.contact-menu-btn').forEach(b => b.setAttribute('aria-expanded','false'));
  }

  // create popover in body and position it to avoid clipping
  function toggleContactMenu(triggerBtn, card, item) {
    // close existing for same contact
    const existing = document.querySelector('.contact-popover[data-for="' + (item.contact||'') + '"]');
    if (existing) { existing.classList.remove('show'); setTimeout(()=> existing.remove(), 160); return; }

    closeAllContactMenus();

    const menu = document.createElement('div');
    menu.className = 'contact-popover';
    menu.setAttribute('data-for', item.contact || '');
    menu.innerHTML = `
      <button data-action="open">Open Chat</button>
      <button data-action="block">Block</button>
      <button data-action="delete" class="danger">Delete Chat</button>
    `;
    document.body.appendChild(menu);

    // position it using trigger bounding rect (keep within viewport)
    const rect = triggerBtn.getBoundingClientRect();
    const menuW = Math.min(menu.offsetWidth || 200, window.innerWidth - 16);
    let left = rect.right - menuW + 8;
    left = Math.max(8, Math.min(left, window.innerWidth - menuW - 8));
    const top = rect.bottom + window.scrollY + 8;
    menu.style.left = left + 'px';
    menu.style.top = top + 'px';

    requestAnimationFrame(()=> menu.classList.add('show'));
    try { triggerBtn.setAttribute('aria-expanded','true'); } catch(e){}

    // actions
    menu.querySelector('[data-action="open"]').addEventListener('click', (e) => {
      e.stopPropagation();
      const qs = new URLSearchParams();
      qs.set('t', item.contact === 'self' ? 'self' : (item.peer_token || item.contact));
      if (profile && profile.name) qs.set('username', profile.name);
      window.location.href = '/chat?' + qs.toString();
      closeAllContactMenus();
    });

    menu.querySelector('[data-action="block"]').addEventListener('click', (e) => {
      e.stopPropagation();
      if (confirm(`Block ${item.name || item.contact}?`)) {
        card.style.opacity = '0.5';
        // TODO: call API to block
      }
      closeAllContactMenus();
    });

    menu.querySelector('[data-action="delete"]').addEventListener('click', (e) => {
      e.stopPropagation();
      if (confirm(`Delete chat with ${item.name || item.contact}?`)) {
        card.remove();
        // TODO: notify server
      }
      closeAllContactMenus();
    });

    // outside click closes (one-time listener)
    const onDoc = (ev) => {
      if (!menu.contains(ev.target) && !triggerBtn.contains(ev.target)) {
        menu.classList.remove('show');
        setTimeout(()=> menu.remove(), 160);
        document.removeEventListener('click', onDoc);
      }
    };
    setTimeout(()=> document.addEventListener('click', onDoc), 10);
  }

  // --- load contacts from server and render (FIXED VERSION) ---
  async function loadContacts() {
    const container = document.getElementById('contactsContainer');
    if (container) container.innerHTML = '';
    if (!container) return;
  
    try {
      // 1Ô∏è‚É£ Load local profile
      const profileLocal = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
      const username = (profileLocal.name || profileLocal.username || '').trim();
  
      // 2Ô∏è‚É£ Build correct URL
      const url = username 
        ? `/contacts_list?username=${encodeURIComponent(username)}`
        : `/contacts_list`;
  
      // 3Ô∏è‚É£ Fetch server contacts
      const resp = await fetch(url, { credentials: 'same-origin' });
      if (!resp.ok) {
        console.warn("‚ùå Server returned:", resp.status);
        throw new Error("Failed " + resp.status);
      }
  
      const data = await resp.json();
      let serverContacts = data.contacts || [];
  
      console.log("üìå Server contacts:", serverContacts);
  
      // 4Ô∏è‚É£ Load client contacts from IndexedDB (not localStorage)
      const localContacts = await OfflineDB.listContacts();
  
      console.log("üìå Local contacts:", localContacts);
  
      // 5Ô∏è‚É£ Merge local + server (server wins)
      const merged = [...localContacts];
  
      serverContacts.forEach(sc => {
        const idx = merged.findIndex(c => c.contact === sc.contact);
        if (idx >= 0) merged[idx] = sc;
        else merged.push(sc);
      });

  
      // 7Ô∏è‚É£ Update IndexedDB (server overrides local)
      for (const c of merged) {
        await OfflineDB.saveContactLocal(c);
      }
  
      // 8Ô∏è‚É£ Make available globally
      window.FINAL_CONTACTS = merged;
  
      console.log("üìå FINAL_CONTACTS set:", window.FINAL_CONTACTS);
  
      // 9Ô∏è‚É£ Render UI
      renderContacts(merged);
  
    } catch (err) {
      console.error("loadContacts error:", err);
      if (container) {
        container.innerHTML =
          '<div style="padding:18px;color:#c00">Unable to load contacts</div>';
      }
    }
  }
  /* === contact edit / add UI helpers & updated render/toggle menu === */
  function getLocalContactName(contactId) {
    try {
      const map = JSON.parse(localStorage.getItem('local_contact_names') || '{}');
      return map[contactId] || null;
    } catch (e) { return null; }
  }
  function setLocalContactName(contactId, name) {
    try {
      const map = JSON.parse(localStorage.getItem('local_contact_names') || '{}');
      map[contactId] = name;
      localStorage.setItem('local_contact_names', JSON.stringify(map));
    } catch (e) {}
  }
  
  // helper: mark contact added locally (for invite flow)
  function markContactAddedLocal(contactId) {
    try {
      const map = JSON.parse(localStorage.getItem('local_contacts_added') || '{}');
      map[contactId] = true;
      localStorage.setItem('local_contacts_added', JSON.stringify(map));
    } catch (e) {}
  }
  function isContactAddedLocal(contactId) {
    try {
      const map = JSON.parse(localStorage.getItem('local_contacts_added') || '{}');
      return !!map[contactId];
    } catch (e) { return false; }
  }
  
  // show a small modal prompt (title, placeholder, initial, onSubmit(name))
  function showPromptModal({ title = 'Name', placeholder = '', initial = '', submitText = 'Save' }, onSubmit) {
    const overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.35);display:flex;align-items:center;justify-content:center;z-index:6000;';
    const dlg = document.createElement('div');
    dlg.style.cssText = 'width:92%;max-width:420px;background:white;padding:16px;border-radius:10px;box-shadow:0 12px 40px rgba(2,6,23,0.2);font-family:Poppins, sans-serif;';
    dlg.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <strong style="font-size:16px">${escapeHtml(title)}</strong>
        <button id="__prompt_close" style="background:none;border:none;font-size:18px;cursor:pointer">‚úñ</button>
      </div>
      <div style="margin-bottom:8px">
        <input id="__prompt_input" placeholder="${escapeHtml(placeholder)}" value="${escapeHtml(initial)}"
          style="width:100%;padding:10px;border:1px solid #ddd;border-radius:8px;font-size:14px" />
      </div>
      <div style="text-align:right">
        <button id="__prompt_cancel" style="margin-right:8px;padding:8px 12px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer">Cancel</button>
        <button id="__prompt_submit" style="padding:8px 12px;border-radius:8px;border:none;background:#0f172a;color:#fff;cursor:pointer">${escapeHtml(submitText)}</button>
      </div>
    `;
    overlay.appendChild(dlg);
    document.body.appendChild(overlay);
    const input = dlg.querySelector('#__prompt_input');
    input.focus();
    const clean = () => overlay.remove();
    dlg.querySelector('#__prompt_close').addEventListener('click', clean);
    dlg.querySelector('#__prompt_cancel').addEventListener('click', clean);
    dlg.querySelector('#__prompt_submit').addEventListener('click', () => {
      const val = input.value.trim();
      if (!val) { input.focus(); return; }
      onSubmit(val);
      clean();
    });
    // enter to submit
    input.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') { ev.preventDefault(); dlg.querySelector('#__prompt_submit').click(); } });
  }
  
  // update just the displayed name in the card element (if present)
  function updateCardDisplayedName(contactId, newName) {
    const card = document.querySelector(`.contact-card[data-contact="${CSS.escape(contactId)}"]`);
    if (!card) return;
    const nameEl = card.querySelector('.contact-name');
    if (nameEl) nameEl.textContent = newName;
  }
  
  async function renderContacts(list) {
    const container = document.getElementById('contactsContainer');
    if (!container) return;
  
    // ------------------------------------------
    // 1) CLEAN DUPLICATES ‚Äî final guaranteed fix
    // ------------------------------------------
    list = Array.isArray(list) ? [...list] : [];
  
    list = list.filter((item, index, arr) => {
      const cid = String(item.contact || "").toLowerCase();
  
      // Allow only ONE self
      if (cid === "self") {
        return arr.findIndex(x => String(x.contact || "").toLowerCase() === "self") === index;
      }
  
      // Normal contacts dedupe
      return arr.findIndex(x =>
        String(x.contact || "").toLowerCase() === cid
      ) === index;
    });
    // ------------------------------------------
  
    const addBox = document.getElementById('addContactsBox');
    const profile = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
    const userLabel = profile.name || profile.username || 'You';

    list.sort((a, b) => (b.last_ts || 0) - (a.last_ts || 0));
  
    // Count real contacts
    const realContacts = list.filter(c => (c.contact || '').toLowerCase() !== 'self');
  
    // Show/hide Add Contacts UI
    if (realContacts.length === 0) {
      if (addBox) addBox.style.display = 'flex';
      if (typeof removeHeaderAddButton === 'function') removeHeaderAddButton();
    } else {
      if (addBox) addBox.style.display = 'none';
      if (typeof ensureHeaderAddButton === 'function') ensureHeaderAddButton();
    }
  
    // token map
    let contactTokens = {};
    try { contactTokens = JSON.parse(localStorage.getItem('contact_tokens') || '{}') || {}; } catch { contactTokens = {}; }
  
    const randAlnum = (len) => {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      return Array.from({ length: len }, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('');
    };
  
    // Clear old DOM (you forgot this ‚Äî also caused dupes)
    container.innerHTML = "";
  
    list.forEach(item => {
      const contactId = (item.contact || '').toString();
      const localName = typeof getLocalContactName === 'function' ? getLocalContactName(contactId) : null;
      const displayName = localName || item.name || contactId || 'Unknown';
      const lastText = item.last_text || '';
  
      const card = document.createElement('div');
      card.className = 'contact-card';
      card.dataset.contact = contactId;
      card.style.cssText = 'display:flex;align-items:center;gap:12px;padding:10px;position:relative;cursor:pointer;border-radius:8px;';
  
      const avatarHtml = item.avatar_url
        ? `<img src="${escapeHtml(item.avatar_url)}" style="width:56px;height:56px;object-fit:cover;border-radius:8px;">`
        : `<div style="width:56px;height:56px;display:flex;align-items:center;justify-content:center;background:#e6eef7;border-radius:8px;font-weight:700;color:#0f172a">${escapeHtml((displayName||'?')[0])}</div>`;
  
      card.innerHTML = `
        <div class="contact-avatar">${avatarHtml}</div>
        <div style="flex:1;min-width:0">
          <div class="contact-name" style="font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHtml(displayName)}</div>
          <div class="contact-last" style="color:#64748b;font-size:0.9rem;margin-top:6px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${escapeHtml(lastText)}</div>
        </div>
        <div style="display:flex;align-items:center;gap:8px">
          <div style="color:#94a3b8;font-size:0.85rem;white-space:nowrap">${item.last_ts ? new Date(item.last_ts * 1000).toLocaleString() : ''}</div>
          <button class="contact-menu-btn" title="Options" aria-haspopup="true" aria-expanded="false"
            style="background:none;border:none;padding:6px;cursor:pointer">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="5" r="1"></circle>
              <circle cx="12" cy="12" r="1"></circle>
              <circle cx="12" cy="19" r="1"></circle>
            </svg>
          </button>
        </div>
      `;
  
      card.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.target.closest('.contact-menu-btn')) return;
  
        const profileLocal = JSON.parse(localStorage.getItem('infinity_profile') || '{}');
        const username = (profileLocal.username || profileLocal.name || 'you').toString();
        const contactId = (item.contact || '').toString();
        const peerRaw = item.peer_token || contactId;
        const isSelf = contactId === 'self' || peerRaw === 'self' || peerRaw === username;
  
        let t = null;
        if (isSelf) {
          const deterministicToken = 'self_' + username;
          localStorage.setItem('__self_chat_token', deterministicToken);
          t = deterministicToken;
  
          try {
            await fetch(window.location.origin + '/api/set_session', {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ username }),
              credentials: 'include'
            });
          } catch {}
        } else {
          try { contactTokens = JSON.parse(localStorage.getItem('contact_tokens') || '{}') || {}; } catch { contactTokens = {}; }
          const key = contactId || ('c_' + (item.phone || item.contact_name || randAlnum(8)));
          if (contactTokens[key] && /^[A-Za-z0-9]{25}$/.test(contactTokens[key])) {
            t = contactTokens[key];
          } else {
            const newToken = randAlnum(25);
            contactTokens[key] = newToken;
            localStorage.setItem('contact_tokens', JSON.stringify(contactTokens));
            t = newToken;
          }
        }
  
        const qs = new URLSearchParams();
        qs.set('t', t);
        if (profileLocal && profileLocal.name) qs.set('username', profileLocal.name);
  
        window.location.href = '/chat?' + qs.toString();
      });
  
      const menuBtn = card.querySelector('.contact-menu-btn');
      if (menuBtn) {
        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (typeof toggleContactMenu === 'function') toggleContactMenu(card, item);
        });
      }
  
      container.appendChild(card);
    });
  }

  // Close all existing popovers (body-level)
  function closeAllContactMenus() {
    document.querySelectorAll('.contact-popover').forEach(p => p.remove());
    document.querySelectorAll('.contact-menu-btn').forEach(b => b.setAttribute('aria-expanded','false'));
  }
  
  function toggleContactMenu(card, item) {
    closeAllContactMenus();
  
    const contactId = (item.contact || '').toString();
    const isSelf = contactId === 'self';
  
    // build container
    const menu = document.createElement('div');
    menu.className = 'contact-popover';
    menu.style.cssText = `
      position:absolute;
      min-width:160px;
      padding:6px;
      border-radius:10px;
      background:linear-gradient(180deg,rgba(255,255,255,0.95),rgba(250,250,250,0.9));
      box-shadow:0 8px 30px rgba(2,6,23,0.12);
      z-index:5000;
    `;
  
    // helper to create buttons
    const makeBtn = (label, extra = '') => {
      const b = document.createElement('button');
      b.textContent = label;
      b.className = extra;
      b.type = 'button';
      b.style.cssText = `
        display:block;width:100%;text-align:left;padding:8px 10px;
        border:none;background:transparent;cursor:pointer;
        border-radius:8px;font-family:Poppins,sans-serif;
      `;
      b.onmouseover = () => (b.style.background = 'rgba(15,23,42,0.04)');
      b.onmouseout = () => (b.style.background = 'transparent');
      return b;
    };
  
    // --- 1. Open Chat ---
    const btnOpen = makeBtn('Open Chat');
    btnOpen.onclick = e => {
      e.stopPropagation();
      card.click();
      closeAllContactMenus();
    };
    menu.appendChild(btnOpen);
  
    // --- 2. Edit Contact ---
    if (!isSelf) {
      const btnEdit = makeBtn('Edit Contact');
      btnEdit.onclick = e => {
        e.stopPropagation();
        const existing = getLocalContactName(contactId) || item.name || '';
        showPromptModal(
          { title: 'Edit Contact Name', placeholder: 'Full name', initial: existing, submitText: 'Save' },
          newName => {
            setLocalContactName(contactId, newName);
            updateCardDisplayedName(contactId, newName);
          }
        );
        closeAllContactMenus();
      };
      menu.appendChild(btnEdit);
    }
  
    // --- 3. Add Contact ---
    const serverAdded = !!item.added;
    const localAdded = isContactAddedLocal(contactId);
    if (!isSelf && !serverAdded && !localAdded) {
      const btnAdd = makeBtn('Add Contact');
      btnAdd.style.fontWeight = '600';
      btnAdd.onclick = async e => {
        e.stopPropagation();
        showPromptModal(
          { title: 'Add Contact', placeholder: 'Enter name', initial: item.name || '', submitText: 'Add' },
          async name => {
            setLocalContactName(contactId, name);
            updateCardDisplayedName(contactId, name);
            try {
              const resp = await fetch('/contacts_list', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contacts: [{ contact: contactId, name }] }),
                credentials: 'same-origin'
              });
              markContactAddedLocal(contactId);
              if (resp.ok) showToast('Contact added');
            } catch {
              markContactAddedLocal(contactId);
            }
          }
        );
        closeAllContactMenus();
      };
      menu.appendChild(btnAdd);
    }
  
    // --- 4. Block ---
    const btnBlock = makeBtn('Block');
    btnBlock.onclick = e => {
      e.stopPropagation();
      if (confirm(`Block ${item.name || item.contact}?`)) card.style.opacity = '0.5';
      closeAllContactMenus();
    };
    menu.appendChild(btnBlock);
  
    // --- 5. Delete ---
    const btnDel = makeBtn('Delete Chat', 'danger');
    btnDel.style.color = '#b91c1c';
    btnDel.onclick = e => {
      e.stopPropagation();
      if (confirm(`Delete chat with ${item.name || item.contact}?`)) card.remove();
      closeAllContactMenus();
    };
    menu.appendChild(btnDel);
  
    // --- position popover ---
    document.body.appendChild(menu);
    const rect = card.querySelector('.contact-menu-btn')?.getBoundingClientRect() || card.getBoundingClientRect();
    const menuW = Math.min(menu.offsetWidth || 220, window.innerWidth - 16);
    let left = rect.right - menuW + 8;
    left = Math.max(8, Math.min(left, window.innerWidth - menuW - 8));
    const top = rect.bottom + window.scrollY + 8;
    Object.assign(menu.style, { left: `${left}px`, top: `${top}px`, opacity: '0', transform: 'translateY(-6px)' });
    requestAnimationFrame(() => {
      menu.style.transition = 'opacity .18s ease, transform .18s ease';
      menu.style.opacity = '1';
      menu.style.transform = 'translateY(0)';
    });
  
    // --- outside click closes ---
    setTimeout(() => {
      const onDoc = ev => {
        if (!menu.contains(ev.target) && !card.contains(ev.target)) {
          menu.remove();
          document.removeEventListener('click', onDoc);
        }
      };
      document.addEventListener('click', onDoc);
    }, 10);
  }
  
  // --- nav bindings ---
  function bindNav() {
    const routes = {
      'nav-calls': '/calls',
      'nav-Updates': '/Updates',
      'nav-chats': '/inbox',
      'nav-settings': '/settings'
    };
    Object.entries(routes).forEach(([id, path]) => {
      const el = document.getElementById(id);
      if (el) el.onclick = () => { window.location.href = path; };
    });
  }
  bindNav();
  
  // expose for console testing
  window.renderContacts = renderContacts;
  window.__infinity = window.__infinity || {};
  window.__infinity.closeContactMenus = closeAllContactMenus;
  
  // initial contact load
  startOfflineDB();
  loadContacts();
})();

// === InfinityChatter: exact header UI + iOS nav style + corrected nav routing ===
(function() {
  // ---- helpers ----
  function loadFontsOnce() {
    if (!document.querySelector('link[href*="Pacifico"]')) {
      const fonts = document.createElement("link");
      fonts.href = "https://fonts.googleapis.com/css2?family=Pacifico&family=Poppins:wght@400;600&display=swap";
      fonts.rel = "stylesheet";
      document.head.appendChild(fonts);
    }
  }

  function safeInitIcons() {
    try {
      if (window.lucide && typeof window.lucide.createIcons === "function") {
        window.lucide.createIcons();
      } else if (window.lucide?.default?.createIcons) {
        window.lucide.default.createIcons();
      }
    } catch (err) { console.error("Lucide init error:", err); }
  }

  function loadLucideOnce(callback) {
    if (window.lucide || document.querySelector('script[src*="lucide"]')) {
      if (typeof callback === 'function') callback();
      safeInitIcons();
      return;
    }
    const s = document.createElement('script');
    s.src = "https://unpkg.com/lucide@0.395.0/dist/umd/lucide.min.js";
    s.async = true;
    s.onload = () => { safeInitIcons(); if (typeof callback === 'function') callback(); };
    document.head.appendChild(s);
  }

  // ---- UI ----
  loadFontsOnce();
  loadLucideOnce();

  document.querySelectorAll("header").forEach(el => el.remove());
  const header = document.createElement("header");
  header.style.cssText = `
    width:100%;
    background:#fff;
    padding:14px 20px 10px;
    position:fixed;
    top:0;
    left:0;
    z-index:1000;
    box-shadow:0 1px 10px rgba(0,0,0,0.05);
    display:flex;
    flex-direction:column;
    align-items:flex-start;
  `;
  header.innerHTML = `
    <div style="font-family:'Pacifico',cursive;font-size:32px;font-weight:500;color:#0f172a;line-height:1;">InfinityChatter</div>
    <div id="subLabel" style="font-family:'Poppins',sans-serif;font-size:15px;color:#475569;margin-top:3px;">Chats</div>
  `;
  document.body.prepend(header);

  const nav = document.querySelector('.bottom-nav');
  const tabs = [
    { id: "chats", icon: "message-circle", label: "Chats" },
    { id: "calls", icon: "phone", label: "Calls" },
    { id: "Updates", icon: "user", label: "Updates" },
    { id: "settings", icon: "settings", label: "Settings" }
  ];

  if (!nav) {
    console.warn("‚ö†Ô∏è .bottom-nav not found");
  } else {
    nav.classList.add("ios-bottom-nav");
    nav.style.cssText = `
      position:fixed;
      bottom:20px;
      left:50%;
      transform:translateX(-50%);
      width:92%;
      max-width:480px;
      background:rgba(255,255,255,0.55);
      backdrop-filter:blur(30px) saturate(180%);
      border:1px solid rgba(255,255,255,0.4);
      border-radius:40px;
      box-shadow:0 10px 25px rgba(0,0,0,0.12);
      display:flex;
      justify-content:space-around;
      align-items:center;
      padding:10px 0;
      font-family:'Poppins',sans-serif;
      z-index:1000;
      transition:all .3s ease;
    `;

    const existing = Array.from(nav.children);
    function makeIconLabel(tab) {
      const frag = document.createDocumentFragment();
      const i = document.createElement('i');
      i.setAttribute('data-lucide', tab.icon);
      i.style.width = '24px';
      i.style.height = '24px';
      i.style.stroke = '#0f172a';
      frag.appendChild(i);
      const lbl = document.createElement('div');
      lbl.style.fontSize = '12px';
      lbl.style.marginTop = '-2px';
      lbl.style.color = '#0f172a';
      lbl.textContent = tab.label;
      frag.appendChild(lbl);
      return frag;
    }

    for (let i = 0; i < tabs.length; i++) {
      const tab = tabs[i];
      let item = existing[i];
      if (item) {
        while (item.firstChild) item.removeChild(item.firstChild);
        item.appendChild(makeIconLabel(tab));
        item.classList.add('nav-item');
        item.dataset.id = tab.id;
        item.style.cssText = "text-align:center;cursor:pointer;transition:transform .2s;flex:1;";
      } else {
        item = document.createElement('div');
        item.className = 'nav-item';
        item.dataset.id = tab.id;
        item.style.cssText = "text-align:center;cursor:pointer;transition:transform .2s;flex:1;";
        item.appendChild(makeIconLabel(tab));
        nav.appendChild(item);
      }
    }

    safeInitIcons();

    // --- fixed and simplified correct navigation map ---
    const routeMap = {
      chats: "/inbox",          // main chat inbox page
      calls: "/calls",    // call page
      Updates: "/Updates",     // Updates page
      settings: "/settings"    // settings page
    };
  }

  // Elegant non-repeating gradient background
  document.documentElement.style.background = 'linear-gradient(180deg, #f8fafc 0%, #eef2ff 100%)';
  document.documentElement.style.backgroundRepeat = 'no-repeat';
  document.documentElement.style.backgroundAttachment = 'fixed';

  const currTop = parseInt(window.getComputedStyle(document.body).paddingTop || '0', 10);
  if (currTop < 90) document.body.style.paddingTop = '90px';
  const currBottom = parseInt(window.getComputedStyle(document.body).paddingBottom || '0', 10);
  if (currBottom < 130) document.body.style.paddingBottom = '130px';

})();

(function() {
  const routeMap = {
    chats: '/inbox',
    calls: '/calls',
    Updates: '/Updates',
    settings: '/settings'
  };

  // Inject bounce animation style
  const style = document.createElement('style');
  style.textContent = `
    @keyframes navBounce {
      0%   { transform: scale(1); }
      30%  { transform: scale(1.25); }
      60%  { transform: scale(0.9); }
      100% { transform: scale(1); }
    }
    .nav-bounce {
      animation: navBounce 0.35s cubic-bezier(.28,1.25,.47,1.03);
    }
  `;
  document.head.appendChild(style);

  // Add click logic with bounce
  document.querySelectorAll('.bottom-nav .nav-item').forEach(item => {
    item.addEventListener('click', e => {
      e.preventDefault();
      item.classList.remove('nav-bounce');
      void item.offsetWidth; // restart animation
      item.classList.add('nav-bounce');

      const id = item.dataset.id;
      const target = routeMap[id];
      if (target && window.location.pathname !== target) {
        setTimeout(() => window.location.href = target, 250); // navigate after bounce
      }
    });
  });
})();

(function() {
  async function openChatPage(token, username) {
    try {
      const res = await fetch(`/chat?t=${encodeURIComponent(token)}&username=${encodeURIComponent(username)}`, {
        credentials: 'same-origin'
      });
      const html = await res.text();
      
      // Extract only <body> content to avoid duplicating headers/nav
      const temp = document.createElement('div');
      temp.innerHTML = html;
      const newContent = temp.querySelector('#chatContainer') || temp.querySelector('main') || temp;

      // Replace main content area
      const appRoot = document.getElementById('main') || document.body;
      appRoot.innerHTML = newContent.innerHTML;
    } catch (err) {
      console.error('‚ö†Ô∏è Failed to load self chat dynamically:', err);
      window.location.assign(`/chat?t=${encodeURIComponent(token)}&username=${encodeURIComponent(username)}`);
    }
  }

  // Expose globally for use in click handler
  window.openChatPage = openChatPage;
})();

</script>
</body>
</html>
